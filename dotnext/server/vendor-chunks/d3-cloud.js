/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/d3-cloud";
exports.ids = ["vendor-chunks/d3-cloud"];
exports.modules = {

/***/ "(ssr)/./node_modules/d3-cloud/build/d3.layout.cloud.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-cloud/build/d3.layout.cloud.js ***!
  \********************************************************/
/***/ ((module) => {

eval("(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=undefined;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=undefined;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n\nvar dispatch = require(\"d3-dispatch\").dispatch;\n\nvar cloudRadians = Math.PI / 180,\n    cw = 1 << 11 >> 5,\n    ch = 1 << 11;\n\nmodule.exports = function() {\n  var size = [256, 256],\n      text = cloudText,\n      font = cloudFont,\n      fontSize = cloudFontSize,\n      fontStyle = cloudFontNormal,\n      fontWeight = cloudFontNormal,\n      rotate = cloudRotate,\n      padding = cloudPadding,\n      spiral = archimedeanSpiral,\n      words = [],\n      timeInterval = Infinity,\n      event = dispatch(\"word\", \"end\"),\n      timer = null,\n      random = Math.random,\n      cloud = {},\n      canvas = cloudCanvas;\n\n  cloud.canvas = function(_) {\n    return arguments.length ? (canvas = functor(_), cloud) : canvas;\n  };\n\n  cloud.start = function() {\n    var contextAndRatio = getContext(canvas()),\n        board = zeroArray((size[0] >> 5) * size[1]),\n        bounds = null,\n        n = words.length,\n        i = -1,\n        tags = [],\n        data = words.map(function(d, i) {\n          d.text = text.call(this, d, i);\n          d.font = font.call(this, d, i);\n          d.style = fontStyle.call(this, d, i);\n          d.weight = fontWeight.call(this, d, i);\n          d.rotate = rotate.call(this, d, i);\n          d.size = ~~fontSize.call(this, d, i);\n          d.padding = padding.call(this, d, i);\n          return d;\n        }).sort(function(a, b) { return b.size - a.size; });\n\n    if (timer) clearInterval(timer);\n    timer = setInterval(step, 0);\n    step();\n\n    return cloud;\n\n    function step() {\n      var start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n && timer) {\n        var d = data[i];\n        d.x = (size[0] * (random() + .5)) >> 1;\n        d.y = (size[1] * (random() + .5)) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          event.call(\"word\", cloud, d);\n          if (bounds) cloudBounds(bounds, d);\n          else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      if (i >= n) {\n        cloud.stop();\n        event.call(\"end\", cloud, tags, bounds);\n      }\n    }\n  }\n\n  cloud.stop = function() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext(\"2d\").getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    var context = canvas.getContext(\"2d\");\n    context.fillStyle = context.strokeStyle = \"red\";\n    context.textAlign = \"center\";\n\n    return {context: context, ratio: ratio};\n  }\n\n  function place(board, tag, bounds) {\n    var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],\n        startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < .5 ? 1 : -1,\n        t = -dt,\n        dxdy,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5),\n              last;\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.timeInterval = function(_) {\n    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;\n  };\n\n  cloud.words = function(_) {\n    return arguments.length ? (words = _, cloud) : words;\n  };\n\n  cloud.size = function(_) {\n    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;\n  };\n\n  cloud.font = function(_) {\n    return arguments.length ? (font = functor(_), cloud) : font;\n  };\n\n  cloud.fontStyle = function(_) {\n    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;\n  };\n\n  cloud.fontWeight = function(_) {\n    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;\n  };\n\n  cloud.rotate = function(_) {\n    return arguments.length ? (rotate = functor(_), cloud) : rotate;\n  };\n\n  cloud.text = function(_) {\n    return arguments.length ? (text = functor(_), cloud) : text;\n  };\n\n  cloud.spiral = function(_) {\n    return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;\n  };\n\n  cloud.fontSize = function(_) {\n    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;\n  };\n\n  cloud.padding = function(_) {\n    return arguments.length ? (padding = functor(_), cloud) : padding;\n  };\n\n  cloud.random = function(_) {\n    return arguments.length ? (random = _, cloud) : random;\n  };\n\n  cloud.on = function() {\n    var value = event.on.apply(event, arguments);\n    return value === event ? cloud : value;\n  };\n\n  return cloud;\n};\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return \"serif\";\n}\n\nfunction cloudFontNormal() {\n  return \"normal\";\n}\n\nfunction cloudFontSize(d) {\n  return Math.sqrt(d.value);\n}\n\nfunction cloudRotate() {\n  return (~~(Math.random() * 6) - 3) * 30;\n}\n\nfunction cloudPadding() {\n  return 1;\n}\n\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0,\n      n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n    var w = c.measureText(d.text + \"m\").width * ratio,\n        h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n          cr = Math.cos(d.rotate * cloudRadians),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = (w + 0x1f) >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= (cw << 5)) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n        w32 = w >> 5,\n        h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0,\n      x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\n          & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function(t) {\n    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1],\n      x = 0,\n      y = 0;\n  return function(t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:  x += dx; break;\n      case 1:  y += dy; break;\n      case 2:  x -= dx; break;\n      default: y -= dy; break;\n    }\n    return [x, y];\n  };\n}\n\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [],\n      i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction functor(d) {\n  return typeof d === \"function\" ? d : function() { return d; };\n}\n\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n\n},{\"d3-dispatch\":2}],2:[function(require,module,exports){\n// https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar noop = {value: function() {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nexports.dispatch = dispatch;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n},{}]},{},[1])(1)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtY2xvdWQvYnVpbGQvZDMubGF5b3V0LmNsb3VkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsR0FBRyxJQUFzRCxFQUFFLG1CQUFtQixLQUFLLFVBQWtSLENBQUMsYUFBYSwwQkFBMEIsMEJBQTBCLGdCQUFnQixVQUFVLFVBQVUsTUFBTSxTQUFtQyxDQUFDLGdCQUFnQixPQUFDLE9BQU8sb0JBQW9CLDhDQUE4QyxrQ0FBa0MsWUFBWSxZQUFZLG1DQUFtQyxpQkFBaUIsZ0JBQWdCLHNCQUFzQixvQkFBb0IsTUFBTSxTQUFtQyxDQUFDLFlBQVksV0FBVyxZQUFZLFNBQVMsR0FBRztBQUM3MUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCLHlCQUF5Qjs7QUFFMUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNkJBQTZCLEdBQUcsNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0Esc0JBQXNCLFdBQVcsR0FBRyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLGdCQUFnQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxDQUFDLDZCQUE2Qjs7QUFFOUIsWUFBWTs7QUFFWjtBQUNBLDhDQUE4QyxLQUFLLE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtRkFBbUYsT0FBTztBQUMxRjtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZELEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDRCQUE0QjtBQUMvRDtBQUNBOztBQUVBOztBQUVBLCtDQUErQyxhQUFhOztBQUU1RCxDQUFDOztBQUVELENBQUMsR0FBRyxFQUFFLEdBQUc7QUFDVCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVpem1pZnkvLi9ub2RlX21vZHVsZXMvZDMtY2xvdWQvYnVpbGQvZDMubGF5b3V0LmNsb3VkLmpzP2FkY2MiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWc9KGcuZDN8fChnLmQzID0ge30pKTtnPShnLmxheW91dHx8KGcubGF5b3V0ID0ge30pKTtnLmNsb3VkID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gV29yZCBjbG91ZCBsYXlvdXQgYnkgSmFzb24gRGF2aWVzLCBodHRwczovL3d3dy5qYXNvbmRhdmllcy5jb20vd29yZGNsb3VkL1xuLy8gQWxnb3JpdGhtIGR1ZSB0byBKb25hdGhhbiBGZWluYmVyZywgaHR0cDovL3N0YXRpYy5tcmZlaW5iZXJnLmNvbS9idl9jaDAzLnBkZlxuXG52YXIgZGlzcGF0Y2ggPSByZXF1aXJlKFwiZDMtZGlzcGF0Y2hcIikuZGlzcGF0Y2g7XG5cbnZhciBjbG91ZFJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLFxuICAgIGN3ID0gMSA8PCAxMSA+PiA1LFxuICAgIGNoID0gMSA8PCAxMTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSBbMjU2LCAyNTZdLFxuICAgICAgdGV4dCA9IGNsb3VkVGV4dCxcbiAgICAgIGZvbnQgPSBjbG91ZEZvbnQsXG4gICAgICBmb250U2l6ZSA9IGNsb3VkRm9udFNpemUsXG4gICAgICBmb250U3R5bGUgPSBjbG91ZEZvbnROb3JtYWwsXG4gICAgICBmb250V2VpZ2h0ID0gY2xvdWRGb250Tm9ybWFsLFxuICAgICAgcm90YXRlID0gY2xvdWRSb3RhdGUsXG4gICAgICBwYWRkaW5nID0gY2xvdWRQYWRkaW5nLFxuICAgICAgc3BpcmFsID0gYXJjaGltZWRlYW5TcGlyYWwsXG4gICAgICB3b3JkcyA9IFtdLFxuICAgICAgdGltZUludGVydmFsID0gSW5maW5pdHksXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFwid29yZFwiLCBcImVuZFwiKSxcbiAgICAgIHRpbWVyID0gbnVsbCxcbiAgICAgIHJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgY2xvdWQgPSB7fSxcbiAgICAgIGNhbnZhcyA9IGNsb3VkQ2FudmFzO1xuXG4gIGNsb3VkLmNhbnZhcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjYW52YXMgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBjYW52YXM7XG4gIH07XG5cbiAgY2xvdWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGV4dEFuZFJhdGlvID0gZ2V0Q29udGV4dChjYW52YXMoKSksXG4gICAgICAgIGJvYXJkID0gemVyb0FycmF5KChzaXplWzBdID4+IDUpICogc2l6ZVsxXSksXG4gICAgICAgIGJvdW5kcyA9IG51bGwsXG4gICAgICAgIG4gPSB3b3Jkcy5sZW5ndGgsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgdGFncyA9IFtdLFxuICAgICAgICBkYXRhID0gd29yZHMubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICBkLnRleHQgPSB0ZXh0LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgZC5mb250ID0gZm9udC5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgIGQuc3R5bGUgPSBmb250U3R5bGUuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICBkLndlaWdodCA9IGZvbnRXZWlnaHQuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICBkLnJvdGF0ZSA9IHJvdGF0ZS5jYWxsKHRoaXMsIGQsIGkpO1xuICAgICAgICAgIGQuc2l6ZSA9IH5+Zm9udFNpemUuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICBkLnBhZGRpbmcgPSBwYWRkaW5nLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYi5zaXplIC0gYS5zaXplOyB9KTtcblxuICAgIGlmICh0aW1lcikgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgdGltZXIgPSBzZXRJbnRlcnZhbChzdGVwLCAwKTtcbiAgICBzdGVwKCk7XG5cbiAgICByZXR1cm4gY2xvdWQ7XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnQgPCB0aW1lSW50ZXJ2YWwgJiYgKytpIDwgbiAmJiB0aW1lcikge1xuICAgICAgICB2YXIgZCA9IGRhdGFbaV07XG4gICAgICAgIGQueCA9IChzaXplWzBdICogKHJhbmRvbSgpICsgLjUpKSA+PiAxO1xuICAgICAgICBkLnkgPSAoc2l6ZVsxXSAqIChyYW5kb20oKSArIC41KSkgPj4gMTtcbiAgICAgICAgY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBpKTtcbiAgICAgICAgaWYgKGQuaGFzVGV4dCAmJiBwbGFjZShib2FyZCwgZCwgYm91bmRzKSkge1xuICAgICAgICAgIHRhZ3MucHVzaChkKTtcbiAgICAgICAgICBldmVudC5jYWxsKFwid29yZFwiLCBjbG91ZCwgZCk7XG4gICAgICAgICAgaWYgKGJvdW5kcykgY2xvdWRCb3VuZHMoYm91bmRzLCBkKTtcbiAgICAgICAgICBlbHNlIGJvdW5kcyA9IFt7eDogZC54ICsgZC54MCwgeTogZC55ICsgZC55MH0sIHt4OiBkLnggKyBkLngxLCB5OiBkLnkgKyBkLnkxfV07XG4gICAgICAgICAgLy8gVGVtcG9yYXJ5IGhhY2tcbiAgICAgICAgICBkLnggLT0gc2l6ZVswXSA+PiAxO1xuICAgICAgICAgIGQueSAtPSBzaXplWzFdID4+IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID49IG4pIHtcbiAgICAgICAgY2xvdWQuc3RvcCgpO1xuICAgICAgICBldmVudC5jYWxsKFwiZW5kXCIsIGNsb3VkLCB0YWdzLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsb3VkLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2xvdWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Q29udGV4dChjYW52YXMpIHtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICB2YXIgcmF0aW8gPSBNYXRoLnNxcnQoY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5sZW5ndGggPj4gMik7XG4gICAgY2FudmFzLndpZHRoID0gKGN3IDw8IDUpIC8gcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNoIC8gcmF0aW87XG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZWRcIjtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG5cbiAgICByZXR1cm4ge2NvbnRleHQ6IGNvbnRleHQsIHJhdGlvOiByYXRpb307XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZShib2FyZCwgdGFnLCBib3VuZHMpIHtcbiAgICB2YXIgcGVyaW1ldGVyID0gW3t4OiAwLCB5OiAwfSwge3g6IHNpemVbMF0sIHk6IHNpemVbMV19XSxcbiAgICAgICAgc3RhcnRYID0gdGFnLngsXG4gICAgICAgIHN0YXJ0WSA9IHRhZy55LFxuICAgICAgICBtYXhEZWx0YSA9IE1hdGguc3FydChzaXplWzBdICogc2l6ZVswXSArIHNpemVbMV0gKiBzaXplWzFdKSxcbiAgICAgICAgcyA9IHNwaXJhbChzaXplKSxcbiAgICAgICAgZHQgPSByYW5kb20oKSA8IC41ID8gMSA6IC0xLFxuICAgICAgICB0ID0gLWR0LFxuICAgICAgICBkeGR5LFxuICAgICAgICBkeCxcbiAgICAgICAgZHk7XG5cbiAgICB3aGlsZSAoZHhkeSA9IHModCArPSBkdCkpIHtcbiAgICAgIGR4ID0gfn5keGR5WzBdO1xuICAgICAgZHkgPSB+fmR4ZHlbMV07XG5cbiAgICAgIGlmIChNYXRoLm1pbihNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSkgPj0gbWF4RGVsdGEpIGJyZWFrO1xuXG4gICAgICB0YWcueCA9IHN0YXJ0WCArIGR4O1xuICAgICAgdGFnLnkgPSBzdGFydFkgKyBkeTtcblxuICAgICAgaWYgKHRhZy54ICsgdGFnLngwIDwgMCB8fCB0YWcueSArIHRhZy55MCA8IDAgfHxcbiAgICAgICAgICB0YWcueCArIHRhZy54MSA+IHNpemVbMF0gfHwgdGFnLnkgKyB0YWcueTEgPiBzaXplWzFdKSBjb250aW51ZTtcbiAgICAgIC8vIFRPRE8gb25seSBjaGVjayBmb3IgY29sbGlzaW9ucyB3aXRoaW4gY3VycmVudCBib3VuZHMuXG4gICAgICBpZiAoIWJvdW5kcyB8fCAhY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHNpemVbMF0pKSB7XG4gICAgICAgIGlmICghYm91bmRzIHx8IGNvbGxpZGVSZWN0cyh0YWcsIGJvdW5kcykpIHtcbiAgICAgICAgICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgICAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxuICAgICAgICAgICAgICBzdyA9IHNpemVbMF0gPj4gNSxcbiAgICAgICAgICAgICAgbHggPSB0YWcueCAtICh3IDw8IDQpLFxuICAgICAgICAgICAgICBzeCA9IGx4ICYgMHg3ZixcbiAgICAgICAgICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgICAgICAgICAgaCA9IHRhZy55MSAtIHRhZy55MCxcbiAgICAgICAgICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcbiAgICAgICAgICAgICAgbGFzdDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB3OyBpKyspIHtcbiAgICAgICAgICAgICAgYm9hcmRbeCArIGldIHw9IChsYXN0IDw8IG1zeCkgfCAoaSA8IHcgPyAobGFzdCA9IHNwcml0ZVtqICogdyArIGldKSA+Pj4gc3ggOiAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gc3c7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0YWcuc3ByaXRlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNsb3VkLnRpbWVJbnRlcnZhbCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aW1lSW50ZXJ2YWwgPSBfID09IG51bGwgPyBJbmZpbml0eSA6IF8sIGNsb3VkKSA6IHRpbWVJbnRlcnZhbDtcbiAgfTtcblxuICBjbG91ZC53b3JkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3b3JkcyA9IF8sIGNsb3VkKSA6IHdvcmRzO1xuICB9O1xuXG4gIGNsb3VkLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IFsrX1swXSwgK19bMV1dLCBjbG91ZCkgOiBzaXplO1xuICB9O1xuXG4gIGNsb3VkLmZvbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udCA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IGZvbnQ7XG4gIH07XG5cbiAgY2xvdWQuZm9udFN0eWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZvbnRTdHlsZSA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IGZvbnRTdHlsZTtcbiAgfTtcblxuICBjbG91ZC5mb250V2VpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZvbnRXZWlnaHQgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBmb250V2VpZ2h0O1xuICB9O1xuXG4gIGNsb3VkLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3RhdGUgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiByb3RhdGU7XG4gIH07XG5cbiAgY2xvdWQudGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0ZXh0ID0gZnVuY3RvcihfKSwgY2xvdWQpIDogdGV4dDtcbiAgfTtcblxuICBjbG91ZC5zcGlyYWwgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3BpcmFsID0gc3BpcmFsc1tfXSB8fCBfLCBjbG91ZCkgOiBzcGlyYWw7XG4gIH07XG5cbiAgY2xvdWQuZm9udFNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udFNpemUgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBmb250U2l6ZTtcbiAgfTtcblxuICBjbG91ZC5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBwYWRkaW5nO1xuICB9O1xuXG4gIGNsb3VkLnJhbmRvbSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5kb20gPSBfLCBjbG91ZCkgOiByYW5kb207XG4gIH07XG5cbiAgY2xvdWQub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBldmVudC5vbi5hcHBseShldmVudCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGV2ZW50ID8gY2xvdWQgOiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gY2xvdWQ7XG59O1xuXG5mdW5jdGlvbiBjbG91ZFRleHQoZCkge1xuICByZXR1cm4gZC50ZXh0O1xufVxuXG5mdW5jdGlvbiBjbG91ZEZvbnQoKSB7XG4gIHJldHVybiBcInNlcmlmXCI7XG59XG5cbmZ1bmN0aW9uIGNsb3VkRm9udE5vcm1hbCgpIHtcbiAgcmV0dXJuIFwibm9ybWFsXCI7XG59XG5cbmZ1bmN0aW9uIGNsb3VkRm9udFNpemUoZCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjbG91ZFJvdGF0ZSgpIHtcbiAgcmV0dXJuICh+fihNYXRoLnJhbmRvbSgpICogNikgLSAzKSAqIDMwO1xufVxuXG5mdW5jdGlvbiBjbG91ZFBhZGRpbmcoKSB7XG4gIHJldHVybiAxO1xufVxuXG4vLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXG4vLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuZnVuY3Rpb24gY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBkaSkge1xuICBpZiAoZC5zcHJpdGUpIHJldHVybjtcbiAgdmFyIGMgPSBjb250ZXh0QW5kUmF0aW8uY29udGV4dCxcbiAgICAgIHJhdGlvID0gY29udGV4dEFuZFJhdGlvLnJhdGlvO1xuXG4gIGMuY2xlYXJSZWN0KDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKTtcbiAgdmFyIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBtYXhoID0gMCxcbiAgICAgIG4gPSBkYXRhLmxlbmd0aDtcbiAgLS1kaTtcbiAgd2hpbGUgKCsrZGkgPCBuKSB7XG4gICAgZCA9IGRhdGFbZGldO1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuZm9udCA9IGQuc3R5bGUgKyBcIiBcIiArIGQud2VpZ2h0ICsgXCIgXCIgKyB+figoZC5zaXplICsgMSkgLyByYXRpbykgKyBcInB4IFwiICsgZC5mb250O1xuICAgIHZhciB3ID0gYy5tZWFzdXJlVGV4dChkLnRleHQgKyBcIm1cIikud2lkdGggKiByYXRpbyxcbiAgICAgICAgaCA9IGQuc2l6ZSA8PCAxO1xuICAgIGlmIChkLnJvdGF0ZSkge1xuICAgICAgdmFyIHNyID0gTWF0aC5zaW4oZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpLFxuICAgICAgICAgIGNyID0gTWF0aC5jb3MoZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpLFxuICAgICAgICAgIHdjciA9IHcgKiBjcixcbiAgICAgICAgICB3c3IgPSB3ICogc3IsXG4gICAgICAgICAgaGNyID0gaCAqIGNyLFxuICAgICAgICAgIGhzciA9IGggKiBzcjtcbiAgICAgIHcgPSAoTWF0aC5tYXgoTWF0aC5hYnMod2NyICsgaHNyKSwgTWF0aC5hYnMod2NyIC0gaHNyKSkgKyAweDFmKSA+PiA1IDw8IDU7XG4gICAgICBoID0gfn5NYXRoLm1heChNYXRoLmFicyh3c3IgKyBoY3IpLCBNYXRoLmFicyh3c3IgLSBoY3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9ICh3ICsgMHgxZikgPj4gNSA8PCA1O1xuICAgIH1cbiAgICBpZiAoaCA+IG1heGgpIG1heGggPSBoO1xuICAgIGlmICh4ICsgdyA+PSAoY3cgPDwgNSkpIHtcbiAgICAgIHggPSAwO1xuICAgICAgeSArPSBtYXhoO1xuICAgICAgbWF4aCA9IDA7XG4gICAgfVxuICAgIGlmICh5ICsgaCA+PSBjaCkgYnJlYWs7XG4gICAgYy50cmFuc2xhdGUoKHggKyAodyA+PiAxKSkgLyByYXRpbywgKHkgKyAoaCA+PiAxKSkgLyByYXRpbyk7XG4gICAgaWYgKGQucm90YXRlKSBjLnJvdGF0ZShkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyk7XG4gICAgYy5maWxsVGV4dChkLnRleHQsIDAsIDApO1xuICAgIGlmIChkLnBhZGRpbmcpIGMubGluZVdpZHRoID0gMiAqIGQucGFkZGluZywgYy5zdHJva2VUZXh0KGQudGV4dCwgMCwgMCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gICAgZC53aWR0aCA9IHc7XG4gICAgZC5oZWlnaHQgPSBoO1xuICAgIGQueG9mZiA9IHg7XG4gICAgZC55b2ZmID0geTtcbiAgICBkLngxID0gdyA+PiAxO1xuICAgIGQueTEgPSBoID4+IDE7XG4gICAgZC54MCA9IC1kLngxO1xuICAgIGQueTAgPSAtZC55MTtcbiAgICBkLmhhc1RleHQgPSB0cnVlO1xuICAgIHggKz0gdztcbiAgfVxuICB2YXIgcGl4ZWxzID0gYy5nZXRJbWFnZURhdGEoMCwgMCwgKGN3IDw8IDUpIC8gcmF0aW8sIGNoIC8gcmF0aW8pLmRhdGEsXG4gICAgICBzcHJpdGUgPSBbXTtcbiAgd2hpbGUgKC0tZGkgPj0gMCkge1xuICAgIGQgPSBkYXRhW2RpXTtcbiAgICBpZiAoIWQuaGFzVGV4dCkgY29udGludWU7XG4gICAgdmFyIHcgPSBkLndpZHRoLFxuICAgICAgICB3MzIgPSB3ID4+IDUsXG4gICAgICAgIGggPSBkLnkxIC0gZC55MDtcbiAgICAvLyBaZXJvIHRoZSBidWZmZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGggKiB3MzI7IGkrKykgc3ByaXRlW2ldID0gMDtcbiAgICB4ID0gZC54b2ZmO1xuICAgIGlmICh4ID09IG51bGwpIHJldHVybjtcbiAgICB5ID0gZC55b2ZmO1xuICAgIHZhciBzZWVuID0gMCxcbiAgICAgICAgc2VlblJvdyA9IC0xO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KSxcbiAgICAgICAgICAgIG0gPSBwaXhlbHNbKCh5ICsgaikgKiAoY3cgPDwgNSkgKyAoeCArIGkpKSA8PCAyXSA/IDEgPDwgKDMxIC0gKGkgJSAzMikpIDogMDtcbiAgICAgICAgc3ByaXRlW2tdIHw9IG07XG4gICAgICAgIHNlZW4gfD0gbTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWVuKSBzZWVuUm93ID0gajtcbiAgICAgIGVsc2Uge1xuICAgICAgICBkLnkwKys7XG4gICAgICAgIGgtLTtcbiAgICAgICAgai0tO1xuICAgICAgICB5Kys7XG4gICAgICB9XG4gICAgfVxuICAgIGQueTEgPSBkLnkwICsgc2VlblJvdztcbiAgICBkLnNwcml0ZSA9IHNwcml0ZS5zbGljZSgwLCAoZC55MSAtIGQueTApICogdzMyKTtcbiAgfVxufVxuXG4vLyBVc2UgbWFzay1iYXNlZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuZnVuY3Rpb24gY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHN3KSB7XG4gIHN3ID4+PSA1O1xuICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgIHcgPSB0YWcud2lkdGggPj4gNSxcbiAgICAgIGx4ID0gdGFnLnggLSAodyA8PCA0KSxcbiAgICAgIHN4ID0gbHggJiAweDdmLFxuICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgIGggPSB0YWcueTEgLSB0YWcueTAsXG4gICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgICAgbGFzdDtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICBsYXN0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB3OyBpKyspIHtcbiAgICAgIGlmICgoKGxhc3QgPDwgbXN4KSB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApKVxuICAgICAgICAgICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeCArPSBzdztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNsb3VkQm91bmRzKGJvdW5kcywgZCkge1xuICB2YXIgYjAgPSBib3VuZHNbMF0sXG4gICAgICBiMSA9IGJvdW5kc1sxXTtcbiAgaWYgKGQueCArIGQueDAgPCBiMC54KSBiMC54ID0gZC54ICsgZC54MDtcbiAgaWYgKGQueSArIGQueTAgPCBiMC55KSBiMC55ID0gZC55ICsgZC55MDtcbiAgaWYgKGQueCArIGQueDEgPiBiMS54KSBiMS54ID0gZC54ICsgZC54MTtcbiAgaWYgKGQueSArIGQueTEgPiBiMS55KSBiMS55ID0gZC55ICsgZC55MTtcbn1cblxuZnVuY3Rpb24gY29sbGlkZVJlY3RzKGEsIGIpIHtcbiAgcmV0dXJuIGEueCArIGEueDEgPiBiWzBdLnggJiYgYS54ICsgYS54MCA8IGJbMV0ueCAmJiBhLnkgKyBhLnkxID4gYlswXS55ICYmIGEueSArIGEueTAgPCBiWzFdLnk7XG59XG5cbmZ1bmN0aW9uIGFyY2hpbWVkZWFuU3BpcmFsKHNpemUpIHtcbiAgdmFyIGUgPSBzaXplWzBdIC8gc2l6ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gW2UgKiAodCAqPSAuMSkgKiBNYXRoLmNvcyh0KSwgdCAqIE1hdGguc2luKHQpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTcGlyYWwoc2l6ZSkge1xuICB2YXIgZHkgPSA0LFxuICAgICAgZHggPSBkeSAqIHNpemVbMF0gLyBzaXplWzFdLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgc2lnbiA9IHQgPCAwID8gLTEgOiAxO1xuICAgIC8vIFNlZSB0cmlhbmd1bGFyIG51bWJlcnM6IFRfbiA9IG4gKiAobiArIDEpIC8gMi5cbiAgICBzd2l0Y2ggKChNYXRoLnNxcnQoMSArIDQgKiBzaWduICogdCkgLSBzaWduKSAmIDMpIHtcbiAgICAgIGNhc2UgMDogIHggKz0gZHg7IGJyZWFrO1xuICAgICAgY2FzZSAxOiAgeSArPSBkeTsgYnJlYWs7XG4gICAgICBjYXNlIDI6ICB4IC09IGR4OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHkgLT0gZHk7IGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xufVxuXG4vLyBUT0RPIHJldXNlIGFycmF5cz9cbmZ1bmN0aW9uIHplcm9BcnJheShuKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBuKSBhW2ldID0gMDtcbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNsb3VkQ2FudmFzKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbn1cblxuZnVuY3Rpb24gZnVuY3RvcihkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiID8gZCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZDsgfTtcbn1cblxudmFyIHNwaXJhbHMgPSB7XG4gIGFyY2hpbWVkZWFuOiBhcmNoaW1lZGVhblNwaXJhbCxcbiAgcmVjdGFuZ3VsYXI6IHJlY3Rhbmd1bGFyU3BpcmFsXG59O1xuXG59LHtcImQzLWRpc3BhdGNoXCI6Mn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kaXNwYXRjaC8gVmVyc2lvbiAxLjAuMy4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9vcCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHQpO1xuICAgIF9bdF0gPSBbXTtcbiAgfVxuICByZXR1cm4gbmV3IERpc3BhdGNoKF8pO1xufVxuXG5mdW5jdGlvbiBEaXNwYXRjaChfKSB7XG4gIHRoaXMuXyA9IF87XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIGlmICh0ICYmICF0eXBlcy5oYXNPd25Qcm9wZXJ0eSh0KSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHQpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5EaXNwYXRjaC5wcm90b3R5cGUgPSBkaXNwYXRjaC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcbiAgb246IGZ1bmN0aW9uKHR5cGVuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfID0gdGhpcy5fLFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiLCBfKSxcbiAgICAgICAgdCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gVC5sZW5ndGg7XG5cbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpICYmICh0ID0gZ2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUpKSkgcmV0dXJuIHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxuICAgIC8vIE90aGVyd2lzZSwgaWYgYSBudWxsIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJlbW92ZSBjYWxsYmFja3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgaWYgKGNhbGxiYWNrICE9IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xuICAgICAgZWxzZSBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgZm9yICh0IGluIF8pIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3B5ID0ge30sIF8gPSB0aGlzLl87XG4gICAgZm9yICh2YXIgdCBpbiBfKSBjb3B5W3RdID0gX1t0XS5zbGljZSgpO1xuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XG4gIH0sXG4gIGNhbGw6IGZ1bmN0aW9uKHR5cGUsIHRoYXQpIHtcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbih0eXBlLCB0aGF0LCBhcmdzKSB7XG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICBmb3IgKHZhciB0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoLCBjOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjID0gdHlwZVtpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldCh0eXBlLCBuYW1lLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKHR5cGVbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgdHlwZVtpXSA9IG5vb3AsIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpLmNvbmNhdCh0eXBlLnNsaWNlKGkgKyAxKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XG4gIHJldHVybiB0eXBlO1xufVxuXG5leHBvcnRzLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cbn0se31dfSx7fSxbMV0pKDEpXG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-cloud/build/d3.layout.cloud.js\n");

/***/ })

};
;